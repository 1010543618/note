> 参考：
[碰到的一些面试问题 - CSDN博客](https://blog.csdn.net/qq_22844483/article/details/69791573)

# position的值， relative和absolute分别是相对于谁进行定位的？
- absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。
- fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。
- relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
- static 默认值。没有定位，元素出现在正常的流中
- sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出

# 如何解决跨域问题
## 1.JSONP
原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。

由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。

优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。

Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。

前端：
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <script>
    function callback(data){
      document.write('jsonp获取到的数据：'+JSON.stringify(data));
    }
  </script>
  <script type="text/javascript" src="http://localhost:8848"></script>
</body>
</html>
```

后端（Node.js）：
```
const http = require('http')

http.createServer(function(request, response){  
  response.write('callback('+JSON.stringify({a:123,b:456})+')');
  response.end();
}).listen(8848);
```

## 2.通过修改document.domain来跨域

将页面的document.domain设为同一个域名。前提条件：这两个域名必须属于同一个基础域名（一级域名），而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。  

eg：
```
www.domain.com
blog.domain.com
设置document.domain为domain.com  


qqq.www.domain.com
ppp.www.domain.com
设置document.domain为www.domain.com  
```
## 3.使用window.name来进行跨域

window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的

## 4.使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 5.flash、在服务器上设置代理页面等跨域方式。

# XML和JSON的区别？
- 数据体积方面。  
JSON相对于XML来讲，数据的体积小，传递的速度更快些。
- 数据交互方面。  
JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
- 数据描述方面。  
JSON对数据的描述性比XML较差。
- 传输速度方面。  
JSON的速度要远远快于XML。

# 说说你对作用域链的理解

作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。

# 创建AJAX过程

1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象.
1. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
1. 设置响应HTTP请求状态变化的函数.
1. 发送HTTP请求.
1. 获取异步调用返回的数据.
1. 使用JavaScript和DOM实现局部刷新.

Node.js：
```
const http = require('http')
const url = require('url')

http.createServer(function(request, response){
  var params = url.parse(request.url, true).query;
  if(undefined == params.t){
var html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <script>
    var XHR = new XMLHttpRequest();
    XHR.open('get', 'http://localhost:8848?t=a');
    XHR.send(null);
    XHR.onreadystatechange = function () {
        if (XHR.readyState === 4) {
            if ( XHR.status === 200 ) {
              document.write('AJAX获取到的内容为：'+XHR.responseText);
            }
        }
    }
  </script>
</body>
</html>`;
    response.write(html);
    response.end();
  }
  if('a' == params.t){
    response.write('hello world');
    response.end();
  }
}).listen(8848);
```

# HTTP和HTTPS
HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。

默认HTTP的端口号为80，HTTPS的端口号为443。

# 为什么HTTPS安全

因为网络请求需要有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用SSL或TSL协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性。

# 对前端模块化的认识

AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

AMD 是提前执行，CMD 是延迟执行。

AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。

CMD模块方式
```
define(function(require, exports, module) {

  // 模块代码

});
```

# 谈谈性能优化问题
- 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。
- 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等
- 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。
- 请求带宽：压缩文件，开启GZIP
- 开启了GPU硬件加速模式：  
如下设置其实是为了渲染3D样式，但我们设置值为0后，并没有真正使用3D效果，但浏览器却因此开启了GPU硬件加速模式。这种GPU硬件加速在当今PC机及移动设备上都已普及，在移动端的性能提升是相当显著地，所以建议大家在做动画时可以尝试一下开启GPU硬件加速。
```
-webkit-transform:transition3d(0,0,0)
// 或者
-webkit-transform:translateZ(0)
```

# 栈和队列的区别?

栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

队列先进先出，栈先进后出。

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除

# 栈和堆的区别？

栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。

堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。

# 快速排序
1. 确定low，high和pivotkey
2. 从high向前找第一个小于pivotkey的进行交换
3. 从low向后找第一个大于pivotkey的进行交换
4. 直到low==high
5. 由pivotkey分成两半递归1-4
```
<script>
  var arr = [1,4,7,8,5,2,6];
  function quickSort(arr, low, height) {
      if(arr.length <= 1) {
          return arr;
      }
      var num = Math.floor(arr.length / 2);
      var numValue = arr.splice(num, 1);
      var left = [],
          right = [];
      for (var i = 0; i < arr.length; i++) {
          if(arr[i] < numValue) {
              left.push(arr[i])
          } else {
              right.push(arr[i])
          }
      }
      return quickSort(left).concat(numValue,quickSort(right));//递归不断重复比较
  }
  console.log(quickSort(arr));
</script>
```

# 你觉得jQuery或zepto源码有哪些写的好的地方
jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。
```
(function( window, undefined ) {

//用一个函数域包起来，就是所谓的沙箱

//在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局

//把当前沙箱需要的外部变量通过函数参数引入进来

//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数

window.jQuery = window.$ = jQuery;

})( window );
```

jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。

有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。

jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。

# ES6的了解
- 新增模板字符串（为JavaScript提供了简单的字符串插值功能）
- 箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=>outputs）
- for...of（用来遍历数据，例如数组中的值）https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of
- arguments对象可被不定参数和默认参数完美代替。
- ES6将promise对象纳入规范，提供了原生的Promise对象
- 增加了let和const命令，用来声明变量
- 增加了块级作用域。let命令实际上就增加了块级作用域
- ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性
- 还有就是引入module模块的概念
- Symbol数据类型

# js继承方式及其优缺点

- 原型链继承的缺点

一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。

- 借用构造函数（类式继承）

借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承

- 组合式继承

组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。

# 谈谈浮动和清除浮动

浮动的框可以从左或右开始，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。（BFC）

- 浮动产生原因

一般是一个盒子里使用了CSS float浮动属性，导致父级对象盒子不能被撑开，这样CSS float浮动就产生了

- 清除方法（利用clear，或创建新的BFC）

1. clear:both 清除浮动（在父盒子后添加一个空标签，标签样式为clear:both）
1. 父级div定义 overflow:hidden
1. 伪元素清除
```
.clearfix { 
    zoom:1;  //兼容ie 6 7
}
.clearfix:after { 
    content:".";
    display:block;
    height:0;
    clear:both; 
    visibility:hidden;
}
```

# 用过哪些设计模式？
## 工厂模式

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

## 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

注意：
1. 单例类只能有一个实例。
2. 单例类必须自己创建自己的唯一实例。
3. 单例类必须给所有其他对象提供这一实例。

# 你对闭包的理解
使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念

闭包有三个特性：

1. 函数嵌套函数
1. 函数内部可以引用外部的参数和变量
1. 参数和变量不会被垃圾回收机制回收

# Cookie

cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。

弊端: 数量和长度的限制

1. IE6或更低版本最多20个cookie
1. IE7和之后的版本最后可以有50个cookie。
1. Firefox最多50个cookie
1. chrome和Safari没有做硬性限制
1. cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
1. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。
1. 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。

优点: 极高的扩展性和可用性

1. 通过良好的编程，控制保存在cookie中的session对象的大小。
1. 通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
1. 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
1. 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。

# 浏览器本地存储

在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。

html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。

sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。

而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

# web storage和cookie的区别

Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。

除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。

但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生

浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。

localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等

# cookie 和session 的区别：

1.　cookie数据存放在客户的浏览器上，session数据放在服务器上。
2.　cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。
3.　session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
考虑到减轻服务器性能方面，应当使用COOKIE。
4.　个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。


# display:none和visibility:hidden的区别？

display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。

visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    #d1{
      height: 100px;
      overflow: none;
      border: 3px solid black;
    }
    #d1 > div{
      height: 200px;
      background: pink;
    }
    #d2{
      height: 50px;
      overflow: hidden;
      border: 3px solid red;
    }
    #d2 > div{
      height: 200px;
      background: green;
    }
  </style>
</head>
<body>
<div id="d1">
  d1
  <div></div>
</div>

<div id="d2">
  d2
  <div></div>
</div>
</body>
</html>
```

# position:absolute和float属性的异同

共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。

不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。

# 介绍一下box-sizing属性？

box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。

- content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高
- border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content


标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。

# CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？

1. id选择器（ # myid）
2. 类选择器（.myclassname）
3. 标签选择器（div, h1, p）
4. 相邻选择器（h1 + p）
5. 子选择器（ul > li）
6. 后代选择器（li a）
7. 通配符选择器（ * ）
8. 属性选择器（a[rel = "external"]）
9. 伪类选择器（a: hover, li:nth-child）

优先级：!important > 内联 > id > class > tag

## CSS3新增伪类举例：

- p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。
- p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。
- p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。
- p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。
- p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。
- :enabled  :disabled 控制表单控件的禁用状态。
- :checked        单选框或复选框被选中


## CSS3有哪些新特性？

- CSS3实现圆角（border-radius），阴影（box-shadow），
- 对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）
- transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
- 增加了更多的CSS选择器 
- 多背景 
- RGBA
- 新增伪元素：`::selection`（用户选中部分）
- 媒体查询，多栏布局
- border-image

# 对BFC规范的理解？

BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。

# 说说你对语义化的理解？

1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构

2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；

3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；

4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

# DOM操作——怎样添加、移除、移动、复制、创建和查找节点。

## 创建新节点
1. createDocumentFragment()    //创建一个DOM片段
1. createElement()   //创建一个具体的元素
1. createTextNode()   //创建一个文本节点

## 添加、移除、替换、插入
1. appendChild()
1. removeChild()
1. replaceChild()
1. insertBefore() //并没有insertAfter()

## 查找
1. getElementsByTagName()    //通过标签名称
1. getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
1. getElementById()    //通过元素Id，唯一性.

## html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
## 新特性
HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

1. 拖拽释放(Drag and drop) API
1. 语义化更好的内容标签（header,nav,footer,aside,article,section）
1. 音频、视频API(audio,video)
1. 画布(Canvas) API
1. 地理(Geolocation) API
1. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
1. sessionStorage 的数据在浏览器关闭后自动删除
1. 表单控件calendar、date、time、email、url、search
1. 新的技术webworker, websocket, Geolocation


## 移除的元素
纯表现的元素：basefont，big，center，font, s，strike，tt，u；  
对可用性产生负面影响的元素：frame，frameset，noframes；


## 低版本IE支持HTML5新标签
```
IE8/IE7/IE6支持通过document.createElement方法产生的标签，
可以利用这一特性让这些浏览器支持HTML5新标签，
当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
   <!--[if lt IE 9]>
   <script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
   <![endif]-->
如何区分： DOCTYPE声明\新增的结构元素\功能元素
```
# null和undefined的区别？

null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。

当声明的变量还未被初始化时，变量的默认值为undefined。

null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。

undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：
1. 变量被声明了，但没有赋值时，就等于undefined。
1. 调用函数时，应该提供的参数没有提供，该参数等于undefined。
1. 对象没有赋值的属性，该属性的值为undefined。
1. 函数没有返回值时，默认返回undefined。

null表示”没有对象”，即该处不应该有值。典型用法是：
1. 作为函数的参数，表示该函数的参数不是对象。
1. 作为对象原型链的终点。

# new操作符具体干了什么呢?
1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2. 属性和方法被加入到 this 引用的对象中。
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this。

# js延迟加载的方式有哪些？

defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js

# 哪些操作会造成内存泄漏？

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。

垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。

闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）

# IE与其他浏览器不一样的特性？

- IE支持currentStyle，FIrefox使用getComputStyle
- IE使用innerText，Firefox使用textContent
- 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num
- 事件方面：IE：attachEvent：火狐是addEventListener
- 鼠标位置：IE是event.clientX；火狐是event.pageX
- IE使用event.srcElement；Firefox使用event.target
- IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none
- CSS圆角：ie7以下不支持圆角

# javascript对象的几种创建方式
1. 工厂模式
2. 构造函数模式
3. 原型模式
4. 混合构造函数和原型模式
5. 动态原型模式
6. 寄生构造函数模式
7. 稳妥构造函数模式

# javascript继承的6种方法
1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承

# GET和POST的区别，何时使用POST？

- GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符
- POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

Get是通过地址栏来传值，而Post是通过提交表单来传值。

然而，在以下情况中，请使用 POST 请求：

1. 更新服务器上的文件或数据库（GET的话URL一样会加载缓存）
1. 向服务器发送大量数据（POST 没有数据量限制）
1. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

# ajax的缺点和在IE下的问题？
ajax的缺点
1. ajax不支持浏览器back按钮。
2. 安全问题 AJAX暴露了与服务器交互的细节。
3. 对搜索引擎的支持比较弱。
4. 破坏了程序的异常机制。
5. 不容易调试。

# 说说你对Promise的理解
Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise

# 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制
```
Object.prototype.clone = function(){
  var o = this.constructor === Array ? [] : {};
  for(var e in this){
    o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];
  }
  return o;
}
```

# 编写一个方法求一个字符串的字节长度。假设：一个英文字符占用一个字节，一个中文字符占用两个字节
实际的话得看编码
```
function GetBytes(str){
  var len = str.length;
  var bytes = len;
  for(var i=0; i<len; i++){
    if(str.charCodeAt(i) > 255) bytes++;
  }
  return bytes;
}
document.write(GetBytes("你好,as"));
```

# 说说mongoDB和MySQL的区别

MySQL是传统的关系型数据库，MongoDB则是非关系型数据库

mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。

对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：
- 弱一致性（最终一致），更能保证用户的访问速度：
- 文档结构的存储方式，能够更便捷的获取数据。

# attribute和property的区别是什么？

- attribute是dom元素在文档中作为html标签拥有的属性；
- property就是dom元素在js中作为对象拥有的属性。

所以：

对于html的标准属性来说，attribute和property是同步的，是会自动更新的，  
但是对于自定义的属性来说，他们是不同步的

# 请解释什么是事件代理(事件委托)

事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。

# 说说你对MVC和MVVM的理解

## MVC
- View 传送指令到 Controller
- Controller 完成业务逻辑后，要求 Model 改变状态
- Model 将新的数据发送到 View，用户得到反馈

所有通信都是单向的。

## MVVM
MVVM是Model-View-ViewModel的简写。它本质上就是MVC的改进版。MVVM就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。

- View：UI界面
- ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；
- Model：数据访问层


