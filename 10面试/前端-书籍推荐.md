因为曾经在高中买来《C Primer Plus》和大学买来的《Clean Code》（挑战自己买的英文版的结果就啃了一点）给我一种经典的书都特别厚的一本就够读大半年的感觉。加上刚上大学图便宜买的有关做网站的旧书（应该是Table布局和Dreamweaver比较火的时代的书，这些书倒是很薄）让我一度认为做网页不就是table然后tr、td什么的套呗，高大上点不就是div+CSS嘛有什么大不了，给我设计好什么网页不都ok能做出来么？这种感觉。然后看网络课程，在网上找资料学习后才发现以前的自己太逗了，之后就一直靠网络课程、MDN、博客、百科这些渠道学习，但一想到网上大牛们评价特别高的书还没看过就总感觉少了点什么。最近将这些书看了看，发现以前只知道要这么做比较好的地方现在也更加明白这样做的意义，也纠正了以前理解的一些错误。

我这里我只总结一些我以前掌握不扎实的和我认为比较重要的。

# JavaScript高级程序设计
## 第3 章 基本概念
### 3.7.1 理解参数
- 修改arguments数组会改变形参的值（这并不是说它们访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。比如未传入形参时，修改了arguments数组形参值也不会变）
```
function func(para1, para2){
  console.log('修改前', arguments , para1, para2);
  arguments [0] = 'arguements_0';
  arguments [1] = 'arguements_1';
  console.log('修改后', arguments , para1, para2);
}
func('para1')
```

- arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。

## 第4 章 变量、作用域和内存问题
### 4.1 基本类型和引用类型的值
基本类型：
1. Undefined
2. Null
3. Boolean
4. Number
5. String（注意String是基本类型）

引用类型：
1. Object

### 4.1.3 传递参数
ECMAScript 中所有函数的参数都是按值传递的。  
eg：这里的obj形参是创建了一个指针让他与person指针指向同一个地址，obj和person都指向同一个地址，但改变obj的指向person不改变
```
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"
```

### 4.2.2 没有块级作用域
> 使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。

```
// 1.if
if (true) {
    var color = "blue";
}
alert(color); //"blue"

// 2.for
for (var i=0; i < 10; i++){
}
alert(i); //10

// 3.function
function add(num1, num2) {
    var sum = num1 + num2;
    return sum;
}
alert(sum); //由于 sum 不是有效的变量，因此会导致错误
```

### 4.3 垃圾收集
常用标记清除，不常用引用计数

## 第5 章 引用类型
### 5.2 Array 类型
> 如果 slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含 5 项的数组上调用 slice(-2,-1)与调用 slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组。

### 5.2.8 迭代方法
- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
- filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。
- forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true

### 5.2.9 归并方法
> ECMAScript 5 还新增了两个归并数组的方法： reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中， reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。

## 第6 章 面向对象的程序设计
### 6.1.1 属性类型
1. 数据属性
2. 访问器属性（VUE双向绑定实现的基础）

### 6.2　创建对象
1. 工厂模式（使用函数创建对象，为对象添加属性和方法然后返回对象，被构造函数模式取代）
2. 构造函数模式（每个成员都不共用）
3. 原型模式（每个成员都共用）
4. 组合使用构造函数模式和原型模式
5. 动态原型模式
6. 寄生构造函数模式
7. 稳妥构造函数模式

### 6.3　继承
1. 原型链
2. 借用构造函数
3. 组合继承
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承

## 第7 章 函数表达式
### 7.2.2 关于this对象
> 每个函数在被调用时都会自动取得两个特殊变量： this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。

```
// this指向window
var name = "The Window";
var object = {
    name : "My Object",
    getNameFunc : function(){
        return function(){
            return this.name;
        };
    }
};
alert(object.getNameFunc()()); //"The Window"（在非严格模式下）

// this指向window，that指向object
var name = "The Window";
var object = {
    name : "My Object",
    getNameFunc : function(){
    var that = this;
        return function(){
            return that.name;
        };
    }
};
alert(object.getNameFunc()()); //"My Object"
```

### 7.4.3 增强的模块模式
```
var application = function(){
    //私有变量和函数
    var components = new Array();
    //初始化
    components.push(new BaseComponent());
    //创建 application 的一个局部副本
    var app = new BaseComponent();
    //公共接口
    app.getComponentCount = function(){
        return components.length;
    };
    app.registerComponent = function(component){
        if (typeof component == "object"){
             components.push(component);
        }
    };
    //返回这个副本
    return app;
}();
```

## 第8 章 BOM
### 8.1.2 窗口关系及框架
> 如果页面中包含框架，则每个框架都拥有自己的 window 对象，并且保存在 frames 集合中。在 frames集合中，可以通过数值索引（从 0 开始，从左至右，从上到下）或者框架名称来访问相应的 window 对象。每个 window 对象都有一个 name 属性，其中包含框架的名称。

> 在使用框架的情况下，浏览器中会存在多个 Global 对象。在每个框架中定义的全局变量会自动成为框架中 window 对象的属性。由于每个 window 对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。例如， top.Object 并不等于 top.frames[0].Object。这个问题会影响到对跨框架传递的对象使用 instanceof 操作符。



### 8.1.6　间歇调用和超时调用
> 在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。

```
// 超时调用模拟间歇调用
var num = 0;
var max = 10;
function incrementNumber() {
    num++;
    //如果执行次数未达到 max 设定的值，则设置另一次超时调用
    if (num < max) {
        setTimeout(incrementNumber, 500);
    } else {
        alert("Done");
    }
}
setTimeout(incrementNumber, 500);
```

### 8.2　location对象
### 8.3　navigator对象
插件检测
### 8.4　screen对象
> 前面曾经提到过，许多浏览器都会禁用调整浏览器窗口大小的能力，因此上面这行代码不一定在所有环境下都有效。

> 涉及移动设备的屏幕大小时，情况有点不一样。运行 iOS 的设备始终会像是把设备竖着拿在手里一样，因此返回的值是 768×1024。而 Android 设备则会相应调用 screen.width 和 screen.height 的值。

## 第9 章 客户端检测
### 9.3.3　完整的代码
242页

## 第10 章 DOM
### 10.1.8　DocumentFragment类型

VUE使用DocumentFragment优化DOM节点操作

> 在所有节点类型中，只有 DocumentFragment 在文档中没有对应的标记。 DOM 规定文档片段（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。

## 第11 章 DOM 扩展
### 11.3.2 焦点管理
> HTML5 也添加了辅助管理 DOM 焦点的功能。首先就是 document.activeElement 属性，这个属性始终会引用 DOM 中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按 Tab 键）和在代码中调用 focus()方法。

### 11.3.5 自定义数据属性
> HTML5 规定可以为元素添加非标准的属性，但要添加前缀 data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data-开头即可。

```
<div id="myDiv" data-appId="12345" data-myname="Nicholas"></div>

<script>
  //本例中使用的方法仅用于演示
  var div = document.getElementById("myDiv");
  //取得自定义属性的值
  var appId = div.dataset.appId;
  var myName = div.dataset.myname;
  //设置值
  div.dataset.appId = 23456;
  div.dataset.myname = "Michael";
  //有没有"myname"值呢？
  if (div.dataset.myname){
    alert("Hello, " + div.dataset.myname);
  }
</script>

```

## 第12 章 DOM2 和DOM3
> DOM2 级和 3 级的目的在于扩展 DOM API，以满足操作 XML 的所有需求，同时提供更好的错误处理及特性检测能力。从某种意义上讲，实现这一目的很大程度意味着对命名空间的支持。“DOM2 级核心”没有引入新类型，它只是在 DOM1 级的基础上通过增加新方法和新属性来增强了既有类型。“DOM3级核心”同样增强了既有类型，但也引入了一些新类型。

### 12.2.1 访问元素的样式
> 多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的 CSS 属性就是 float。由于 float 是 JavaScript 中的保留字，因此不能用作属性名。“DOM2 级样式”规范规定样式对象上相应的属性名应该是 cssFloat； Firefox、 Safari、 Opera 和 Chrome 都支持这个属性，而 IE支持的则是 styleFloat。

```
<div id="myDiv">myDiv</div>
<script>
    var myDiv = document.getElementById("myDiv");
    //浮动
    myDiv.style.cssFloat = "left";
    //背景颜色
    myDiv.style.backgroundColor = "red";
    //改变大小
    myDiv.style.width = "100px";
    myDiv.style.height = "200px";
    //指定边框
    myDiv.style.border = "1px solid black";
</script>
```

### 12.4 范围
> 为了让开发人员更方便地控制页面，“DOM2 级遍历和范围”模块定义了“范围”（range）接口。通过范围可以选择文档中的一个区域，而不必考虑节点的界限（选择在后台完成，对用户是不可见的）。在常规的 DOM 操作不能更有效地修改文档时，使用范围往往可以达到目的。

## 第13 章 事件
### 13.1.3 DOM事件流
> “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。

### 13.2.2 DOM0 级事件处理程序

使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在
元素的作用域中运行；换句话说，程序中的 this 引用当前元素。来看一个例子。

```
<button id="myBtn">myBtn</button>
<script>
var btn = document.getElementById("myBtn");
btn.onclick = function(){
    alert(this.id); //"myBtn"
};
</script>
```

将事件处理程序属性的值设置为 null 可以删除通过 DOM0 级方法指定的事件处理程序：
`btn.onclick = null; `

### 13.2.3 DOM2 级事件处理程序
> “DOM2 级事件” 定义了两个方法，用于处理指定和删除事件处理程序的操作： addEventListener()和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。

```
<button id="myBtn">myBtn</button>
<script>
var btn = document.getElementById("myBtn");
btn.addEventListener("click", function(){
    alert(this.id);
}, false);
btn.addEventListener("click", function(){
    alert("Hello world!");
}, false);
</script>
```

eg：删除事件时必须传入绑定的事件的“指针”

### 13.2.4 IE事件处理程序
> IE 实现了与 DOM 中类似的两个方法： attachEvent()和 detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于 IE8 及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。

### 13.3 事件对象
> 兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级），都会传入 event 对象。

```
<button id="myBtn">myBtn</button>
<script>
var btn = document.getElementById("myBtn");
btn.onclick = function(event){
  alert(event.type); //"click"
};
btn.addEventListener("click", function(event){
  alert(event.type); //"click"
}, false);
</script>
```
### 13.4.3　鼠标与滚轮事件
iOS 和 Android 设备的实现非常特别，因为这些设备没有鼠标。在面向 iPhone 和 iPod 中的 Safari开发时，要记住以下几点。
- 不支持 dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。
- 轻击可单击元素会触发 mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生 mousedown、 mouseup 和 click 事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了 onclick 事件处理程序的元素。
- mousemove 事件也会触发 mouseover 和 mouseout 事件。
- 两个手指放在屏幕上且页面随手指移动而滚动时会触发 mousewheel 和 scroll 事件。

### 13.4.7 HTML5 事件
- DOMContentLoaded 事件  
window 的 load 事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载的外部资源过多而颇费周折。而 DOMContentLoaded 事件则在形成完整的 DOM 树之后就会触发，不理会图像、 JavaScript 文件、 CSS 文件或其他资源是否已经下载完毕。与 load 事件不同，DOMContentLoaded 支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面进行交互。

### 13.5 内存和性能
- 事件委托  
对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如， click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。

## 第14 章 表单脚本
> 在 HTML 中，表单是由<form>元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。 HTMLFormElement 继承了 HTMLElement，因而与其他 HTML 元素具有相同的默认属性。不过， HTMLFormElement 也有它自己下列独有的属性和方法。

- acceptCharset：服务器能够处理的字符集；等价于 HTML 中的 accept-charset 特性。
- action：接受请求的 URL；等价于 HTML 中的 action 特性。
- elements：表单中所有控件的集合（HTMLCollection）。
- enctype：请求的编码类型；等价于 HTML 中的 enctype 特性。
- length：表单中控件的数量。
- method：要发送的 HTTP 请求类型，通常是"get"或"post"；等价于 HTML 的 method 特性。
- name：表单的名称；等价于 HTML 的 name 特性。
- reset()：将所有表单域重置为默认值。
- submit()：提交表单。
- target：用于发送请求和接收响应的窗口名称；等价于 HTML 的 target 特性。

### 14.5.4 表单与富文本
> 由于富文本编辑是使用 iframe 而非表单控件实现的，因此从技术上说，富文本编辑器并不属于表单。换句话说，富文本编辑器中的 HTML 不会被自动提交给服务器，而需要我们手工来提取并提交HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从 iframe 中提取出的 HTML。具体来说，就是在提交表单之前，从 iframe 中提取出 HTML，并将其插入到隐藏的字段中。


## 第15 章 使用Canvas 绘图
### 15.2.5 变换
> 如果你知道将来还要返回某组属性与变换的组合，可以调用 save()方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用 restore()方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。连续调用 save()可以把更多设置保存到栈结构中，之后再连续调用 restore()则可以一级一级返回。

```
<canvas id="drawing" width=" 200" height="200">A drawing of something.</canvas>
<script>
var drawing = document.getElementById("drawing");
//确定浏览器支持<canvas>元素
if (drawing.getContext){
    var context = drawing.getContext("2d");
    context.fillStyle = "#ff0000";
    context.save(); //save1
    context.fillStyle = "#00ff00";
    context.translate(100, 100);
    context.save(); //save2
    context.fillStyle = "#0000ff";
    context.fillRect(0, 0, 100, 200); //从点(100,100)开始绘制蓝色矩形
    context.restore(); //返回save2
    context.fillRect(10, 10, 100, 200); //从点(110,110)开始绘制绿色矩形
    context.restore(); //返回save2
    context.fillRect(0, 0, 50, 50); //从点(0,0)开始绘制红色矩形
}
</script>
```
### 15.3 WebGL
书上的太难理解了！
> https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API

## 第16 章 HTML5 脚本编程
### 16.1　跨文档消息传递
> 跨文档消息传送（cross-document messaging），有时候简称为 XDM，指的是在来自不同域的页面间传递消息。例如， www.wrox.com 域中的页面与位于一个内嵌框架中的 p2p.wrox.com 域中的页面通信。在 XDM 机制出现之前，要稳妥地实现这种通信需要花很多工夫。 XDM 把这种机制规范化，让我们能既稳妥又简单地实现跨文档通信。

> XDM 的核心是 postMessage()方法。在 HTML5 规范中，除了 XDM 部分之外的其他部分也会提到这个方法名，但都是为了同一个目的：向另一个地方传递数据。对于 XDM 而言， “另一个地方”指的是包含在当前页面中的<iframe>元素，或者由当前页面弹出的窗口。

### 16.2 原生拖放
拖动某元素时，将依次触发下列事件：
1. dragstart
1. drag
1. dragend

当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生：
1. dragenter
1. dragover
1. dragleave 或 drop

## 第17 章 错误处理与调试
### 17.2.1 try-catch语句
> ECMA-262 第 3 版引入了 try-catch 语句，作为 JavaScript 中处理异常的一种标准方式。这与 Java 中的 try-catch 语句是完全相同的。

```
try{
    // 可能会导致错误的代码
} catch(error){
    // 在错误发生时怎么处理
}
```

> 只要代码中包含 finally 子句，则无论 try 或 catch 语句块中包含什么代码——甚至 return 语句，都不会阻止 finally 子句的执行。来看下面这个函数。

```
<script>
alert(testFinally());// 0
function testFinally(){
    try {
        return 2;
        alert('try');// 不执行
    } catch (error){
        return 1;
    } finally {
        return 0;
    }
}
</script>
```
#### 致命错误和非致命错误
非致命错误，可以根据下列一或多个条件来确定：
- 不影响用户的主要任务；
- 只影响页面的一部分；
- 可以恢复；
- 重复相同操作可以消除错误。

eg：非致命错误添加try-catch可以使非致命错误发生后后续代码继续执行，后面的模块继续加载

致命错误，可以通过以下一或多个条件来确定：
- 应用程序根本无法继续运行；
- 错误明显影响到了用户的主要操作；
- 会导致其他连带错误。

#### 把错误记录到服务器
> 建立这样一种 JavaScript 错误记录系统，首先需要在服务器上创建一个页面（或者一个服务器入口点），用于处理错误数据。这个页面的作用无非就是从查询字符串中取得数据，然后再将数据写入错误日志中。这个页面可能会使用如下所示的函数：

```
function logError(sev, msg){
    var img = new Image();
    img.src = "log.php?sev=" + encodeURIComponent(sev) + "&msg=" + encodeURIComponent(msg);
}
```

> 这个 logError()函数接收两个参数：表示严重程度的数值或字符串（视所用系统而异）及错误消息。其中，使用了 Image 对象来发送请求，这样做非常灵活，主要表现如下几方面。

- 所有浏览器都支持 Image 对象，包括那些不支持 XMLHttpRequest 对象的浏览器。
- 可以避免跨域限制。通常都是一台服务器要负责处理多台服务器的错误，而这种情况下使用XMLHttpRequest 是不行的。
- 在记录错误的过程中出问题的概率比较低。大多数 Ajax 通信都是由 JavaScript 库提供的包装函数来处理的，如果库代码本身有问题，而你还在依赖该库记录错误，可想而知，错误消息是不可能得到记录的。

## 第18 章 JavaScript 与XML，第19 章 E4X
XML相关

## 第20 章 JSON
JSON 的语法可以表示以下三种类型的值。
- 简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。
- 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。
- 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。

> 与 JavaScript 的对象字面量相比， JSON 对象有两个地方不一样。首先，没有声明变量（JSON 中没有变量的概念）。其次，没有末尾的分号（因为这不是 JavaScript 语句，所以不需要分号）。再说一遍，对象的属性必须加双引号，这在 JSON 中是必需的。属性的值可以是简单值，也可以是复杂类型值。

### 20.2.2 序列化选项
> JSON.stringify()除了要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化 JavaScript 对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在 JSON 字符串中保留缩进。








# JavaScript DOM编程艺术 第2版

## 第5五章 最佳实践
1. 平稳退化：~~现在基本所有带交互的网站都使用Ajax，SAP也火起来了，平稳退化真是很难实现了~~（看到第七章发现我之前的观点是错了）
2. 分离JS
3. 向下兼容
4. 性能考虑

## 第6章 案例研究：图片库改进版 
1. 键盘访问（提高可访问性）  
onclick已经帮我们处理了，eg：下面这个绑定了onclick的按钮鼠标左键点击和tab然后回车一样弹出"clicked"
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <button onclick="alert('clecked')">"click" me</button>
</body>
</html>
```
2. DOM core和HTML-DOM  
由于HTML与XML的相似性及差异，JavaScript不仅实现了标准的DOM方法和属性（即由W3C制定的），而且还实现了HTML特有的DOM方法和属性。  
DOM Core：标准的DOM方法和属性  
HTML-DOM：HTML特有的DOM方法和属性  

## 第7章 动态创建标记
### 若元素存在只是为了让DOM方法处理他们，那么用DOM方法来创建他们才是最合适的选择

### ==渐进增强与Ajax==
一开始以Ajax为起点设计网站很难做到平稳退化，但一开始用老式的页面刷新机制设计网站，在此基础上用拦截请求用Ajax技术处理就可以实现平稳退化。（渐进增强：HTML全部完成->CSS全部完成->JS全部完成->网站完成）

==这样得后端也得做一套页面展示（点开链接和平稳退化用），前端不应再页面加载时使Ajax（应该由后端生成）==

## 第8章 充实文档的内容 
### 不应使用DOM技术将重要内容添加到网页上
现在主流的MVVM框架全是使用JS生成DOM。。

### accesskey：快捷键
很多大网站都没见用，FF里要Alt+Shift+c才能使用下面设置的快捷键
```
<a href="http://www.w3school.com.cn/css/" accesskey="c">CSS</a>
```
## 第11章 HTML5 
### Modernizr：HTML5/CSS3 特性检测库

# HTML5与CSS3基础教程（第8版）
## 第1章　网页的构造块
### 文件名和文件夹名  
文件名全部使用小写字母，用短横线分隔单词，用 .html 作为扩展名。混合使用大小写字
母会增加访问者输入正确地址以及找到页面的难度  
文件夹的名称也应全部用小写字母。关键是保持一致。如果使用小写字母，访问者和创建者就
不必在大写字母和小写字母之间转换浪费时间了

### 语意
1. ==提升可访问性和互操作性==（内容对于借
助辅助技术的残障访问者是可访问的，
同时对于台式机、手机、平板电脑及
其他设备上的浏览器都是可访问的）。
1. 提升搜索引擎优化（SEO）的效果。
1. 使维护代码和添加样式变得容易。
1. （通常）使代码更少，页面加载更快。

> 万维网的发明者 Tim BernersLee 曾说过一句著名的话：“万维网的力量在于其普适性。让包括残障人士在内的每个人都能访问万维网，是极为重要的一点。”

### small 
small元素表示的含义是法律声明等条文细则。默认情况下，它比其他的文字显示得小一些，但是==显示小字号并不是使用这个元素的理由==  
（以前一直当small是小号字体=_=）

## 第3章　基本HTML结构
### \<html lang="language-code"\> 
曾经使用Bootstrap4的时候没找到中文翻译，准备自己翻译一下翻译了两页有点感觉有点多，就往下翻了翻看看到底有多少工作量，然后看见有Translations，点进去一看发现大家基本都知道但很容易忘的一项翻译的人给强调出来了：
> HTML5标准的 doctype 头部定义是首要的，否则会导致样式失真（中国码农往往直接抄国外站点将lang写成en的小细节也要注意以免贻笑大方)。

注：以前搜过lang相关的里面的规则很复杂的（[网页头部的声明应该是用 lang="zh" 还是 lang="zh-cn"？ - 知乎](https://www.zhihu.com/question/20797118)），但一般国内的页面现在一般还都是zh-CN。

Emmet设置默认生成的lang为zh-CN：  
下面代码添加到Emmet的Settings-User
```
{
  "snippets": {
    "variables": {
      "lang": "zh-CN"
    }
  }
}
```
### h1 ～ h6
1. 不要使用 h1 ～ h6 标记副标题、标语以及无法成为独立标题的子标题。
2. 创建分级标题时，要避免跳过某些级别，如从 h3 直接跳到 h5。不过，允许从低级别跳到高级别的标题。
3. 要依据内容所处的层次关系选择标题级数，而不是根据你希望文字应该显示的大小。

### main
main元素是 HTML5 新添加的元素。记住，在一个页面里仅使用一次。

### SEO
在 HTML 中，应该将附注栏(aside)内容放在 main 的内容之后。出于 SEO和可访问性的目的，最好将重要的内容放在前面。可以通过 CSS 改变它们在浏览器中的显示顺序。

### 使用 ARIA 改善可访问性
WAI-ARIA（Web Accessibility Initiative’s Accessible Rich Internet Applications，无障碍
网页倡议 – 无障碍的富互联网应用，也简称ARIA）是一种技术规范，自称“有桥梁作用的技术” 。

1. 使用地标角色`role="xxx"`
1. 给元素添加title`title="xxx"`

## 第8章　操作样式表
### @import
@import 指令会影响页面的下载速度和呈现速度，在 Internet Explorer 中影响更为明显。 

### @media
@media 规则只有screen 和 print（或许还应加上 all）浏览器支持的很好。

## 第9章　定义选择器
### 伪元素
- :first-letter：选择元素的第一个字母
- :first-line：选择元素的第一行

:first-line的语法为::first-line。:first-letter的语法为::firstletter。注意，它们用两个冒号代替了单个冒号。这样修改的目的是将伪元素（有四个，包括::first-line、::first-letter、::before和::after）与伪类（如:first-child、:link、:hover等）区分开。

未来，::first-line和::first-letter这样的双冒号语法是推荐的方式，现代浏览器也支持它们。原始的单冒号语法则被废弃了，但浏览器出于向后兼容的目的，仍然支持它们。不过，IE9之前的InternetExplorer版本均不支持双冒号。因此，你可以选择继续使用单冒号语法，除非你为IE8及以下版本设置了单独的CSS。

## 第12章　构建响应式网站
1. 创建内容和 HTML
1. 移动优先方法
1. 逐步完善布局

### 视觉区域（viewport）
`<meta name="viewport" content="width=device-width, initial-scale=1" />`
1. 视觉区域的宽度会被设成与设备宽度
1. 页面的默认缩放级别设成了 100%（换成纵向模式也一样）

### 兼容旧版 IE
使用Respond.js

## 第13章　使用Web 字体
### @font-face

## 第17章　视频、音频和其他多媒体
HTML5 并没有提供任何保护媒体内容的方法。因此，如果你很在意对媒体文件的保护，那么暂时不要使用 HTML5 原生多媒体。

## 附录
[HTML Reference](https://www.htmlcssvqs.com/8ed/appendixes/html-reference.php)

[CSS Reference](https://www.htmlcssvqs.com/8ed/appendixes/css-reference.php)


# 图解CSS3核心技术与案例实战

## 第二章 CSS3选择器
1. 基本选择器：所有浏览器都可用
2. 层次选择器：基本所有浏览器都可用（部分IE7+）
3. 伪类选择器：大部分IE8+9+可用  
E:target：匹配id为hash的元素  
E:lang(language)：匹配lang属性的值为language的元素  
4. 伪元素：IE6~8仅支持单冒号，IE9+支持伪元素  
> 伪元素为DOM树没有定义的虚拟元素。不同于其他选择器，它不以元素为最小选择单元，它选择的是元素指定内容。

使用伪元素可以DOM的部分内容（并非整个DOM）添加样式
5. 属性选择器：基本所有浏览器都可用（IE7+）

## 第三章 CSS3边框
目前：
- border-color：浏览器支持的不是很好，尽量别用
- border-image：IE11才支持，谨慎使用  
使用一张图片切成九宫格（切的顺序：TRBL），用8个边上个格为图片生成边框背景
- border-radius：浏览器支持的不错，IE9+可用  
参数：none | 水平参数{1,4} / [垂直参数{1,4}]?
- box-shadow：和border不同，box-shadow不是盒模型的中的属性，不会计算到宽度

PS：图片圆角我测试可以直接使用，但图片内阴影直接设置无效需要将图片设置为背景，或外面套个div实现

## 第四章 CSS3背景

- 多背景：IE8+支持  
多个背景用逗号隔开


# 单页Web应用  JavaScript从前端到后端

# Web性能权威指南

# 图解TCP/IP(第5版)

# JavaScript设计模式









