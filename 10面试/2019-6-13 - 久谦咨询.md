开启了拉钩的自动投简历，结果投到了上海的久谦咨询，电话面试之前还没明白状况，来电话了问完问题感觉好难啊，然后一查才发现是个厉害的地方😰。

基本答得都不咋地，把答得非常不好的记录一下：

# React 的 this.setState() 会立即更新状态么

如：

```js
this.setState(
    {a: 123}
)
console.log(this.state.a)
```

只知道 setState 会做很多处理肯定不能，但原理真不知道（又是第一题就被问蒙了。。）

正解：

> setState() 不会立刻改变 this.state，而是创建一个即将处理的 state 事务。在调用该方法之后获取 this.state 的值可能会得到现有的值，而不是最新设置的值。不保证 setState() 调用的同步性，为了提升性能，可能会批量执行 state 转变和 DOM 渲染。
>
> 所以，一般情况下，我们想要确保在 state 合并完成之后执行方法，就会把需要执行的内容写在回调函数内。

[为什么 setState 没有立即执行 - 简书](https://www.jianshu.com/p/2d50a413e74a)

# JS new 操作都干了什么

这个见过，但都忘记了，再看一遍吧

正解：

1.  创建一个空对象，并且构造函数的 this 变量引用该对象，同时还继承了该函数的原型（空对象的`[[prototype]]`属性 (也叫`__proto__`) 指向构造函数的`prototype`属性）。
2.  调用构造函数，属性和方法被加入到构造函数的 this 引用的对象中。
3.  新创建的对象由 this 所引用，并且最后隐式的返回 this。

# 说说原型链

这种问题怎么答才算好呢？目前我的理解是：

-   内部隐藏的`[[prototype]]`保存着原型链的信息（类似继承关系）
-   prototype 属性只有构造函数有意义，用于在创建对象时生成对象内部隐藏的`[[prototype]]`

# 讲讲 Redux

只是会用的程度，没有讲明白

正解：

-   Redux 是 JavaScript 状态容器，提供可预测化的状态管理。可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。
-   单一数据源：整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。
-   State 是只读的：唯一改变 state 的方法就是触发 action
-   使用纯函数来执行修改：Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state
